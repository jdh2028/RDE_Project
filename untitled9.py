# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18HWSXJf9hkIlz_VZHSmY1nvFNo7JWGmW
"""

import numpy as np
import matplotlib.pyplot as plt
import CoolProp.CoolProp as CP
from scipy.interpolate import UnivariateSpline
from scipy.signal import savgol_filter

# ==============================================================================
# 0. 노즐 형상 정의 클래스
# ==============================================================================
class NozzleContour:
    """
    사용자가 제공한 (x, y) 좌표 데이터로부터 노즐 형상을 정의하고,
    특정 축 위치(x)에서의 반경, 직경, 면적 등을 계산합니다.
    """
    def __init__(self, contour_data_cm):
        # 데이터를 m 단위로 변환하고 x좌표 기준으로 정렬
        data_m = np.array(contour_data_cm) / 100.0
        x, y = data_m[:, 0], data_m[:, 1]
        sort_idx = np.argsort(x)
        self.x_data, self.y_data = x[sort_idx], y[sort_idx]

        # 목(throat)의 위치와 반경 찾기
        self.throat_idx = np.argmin(self.y_data)
        self.x_throat = self.x_data[self.throat_idx]
        self.R_t = self.y_data[self.throat_idx]
        self.D_t = 2 * self.R_t
        self.A_t = np.pi * self.R_t**2

        # x좌표를 목(throat) 기준으로 재정의 (목이 x=0이 되도록 이동)
        self.x_data_shifted = self.x_data - self.x_throat

        # 스플라인 보간을 사용하여 부드러운 형상 곡선 생성
        self.spline = UnivariateSpline(self.x_data_shifted, self.y_data, s=0, k=3)

    def get_radius(self, x):
        return self.spline(x)

    def get_profile(self, x):
        R = self.get_radius(x)
        A = np.pi * R**2
        D = 2 * R
        area_ratio = A / self.A_t
        return D, area_ratio

# ==============================================================================
# 1. 열 해석 및 유동 관련 함수 정의
# ==============================================================================
def get_gas_properties(T_static):
    # CH4/LOX 연소 가스 물성치 근사 데이터 (T0=3600K, T_exit_approx=2000K)
    T_high, T_low = 3600.0, 2000.0
    gamma_high, gamma_low = 1.15, 1.22
    mu_high, mu_low = 8.0e-5, 6.0e-5
    Cp_high, Cp_low = 3500.0, 2800.0

    gamma = np.interp(T_static, [T_low, T_high], [gamma_low, gamma_high])
    mu = np.interp(T_static, [T_low, T_high], [mu_low, mu_high])
    Cp = np.interp(T_static, [T_low, T_high], [Cp_low, Cp_high])
    return gamma, mu, Cp

def mach_from_area_ratio(area_ratio, gamma, flow_type='subsonic'):
    """면적-마하수 관계(Isentropic)로 M 계산"""
    M = 0.5 if flow_type == 'subsonic' else 2.0
    for _ in range(10):
        f = (1/M**2) * ((2/(gamma+1))*(1+(gamma-1)/2*M**2))**((gamma+1)/(gamma-1)) - area_ratio**2
        if abs(f) < 1e-6: break
        dfdm_term1 = -2/M**3
        dfdm_term2 = ((gamma+1)/(gamma-1)) * (1/(1+(gamma-1)/2*M**2)) * ((gamma-1)/2) * (2*M)
        base = ((2/(gamma+1))*(1+(gamma-1)/2*M**2))**((gamma+1)/(gamma-1))
        dfdm_combined = dfdm_term1*base + (1/M**2)*base*dfdm_term2
        M -= f/dfdm_combined
    return M

def bartz_h_g(Mach, T_wg, D_t, area_ratio, P_c, T_0, gamma, mu, Cp, Pr, C_star):
    """Bartz로 가스측 대류계수 h_g 및 점착온도 T_aw"""
    r = Pr**(1/3)
    T_aw = T_0 * (1 + r*(gamma-1)/2*Mach**2) / (1 + (gamma-1)/2*Mach**2)
    w = 0.6
    term1 = 0.5 * (T_wg/T_0) * (1 + (gamma-1)/2*Mach**2)
    term2 = 0.5
    denominator = (term1 + term2)**(0.8 - w/5) * (1 + (gamma-1)/2*Mach**2)**(w/5)
    sigma_corr = 1/denominator if denominator != 0 else 1.0
    h_g = (0.026/(D_t**0.2)) * ((mu**0.2 * Cp)/(Pr**0.6)) * ((P_c/C_star)**0.8) * (1/area_ratio)**0.9 * sigma_corr
    return h_g, T_aw

def calculate_pressure_drop(m_dot_c, T_c, P_c, A_c, d_h, dx, fluid):
    """Darcy-Weisbach 압력강하"""
    try:
        rho_c = CP.PropsSI('D', 'T', T_c, 'P', P_c, fluid)
        mu_c  = CP.PropsSI('V', 'T', T_c, 'P', P_c, fluid)
        Re_c = (m_dot_c/A_c) * d_h / mu_c
        if Re_c < 4000: return 0.0
        f_friction = 0.316 * Re_c**-0.25  # Blasius
        velocity_c = m_dot_c / (A_c * rho_c)
        dP = f_friction * (dx/d_h) * (rho_c * velocity_c**2 / 2.0)
        return dP
    except ValueError:
        return 0.0

def calculate_h_c(m_dot_c, A_c, d_h, T_c, T_wc, P_c, fluid='Methane'):
    """냉각측 대류계수(Dittus-Boelter). Re<4000이면 보수적으로 낮게."""
    try:
        if not (91 < T_c < 600 and 1e5 < P_c < 200e5): return 30000.0
        cp_c = CP.PropsSI('C', 'T', T_c, 'P', P_c, fluid)
        mu_c = CP.PropsSI('V', 'T', T_c, 'P', P_c, fluid)
        k_c  = CP.PropsSI('L', 'T', T_c, 'P', P_c, fluid)
        Pr_c = cp_c * mu_c / k_c
        Re_c = (m_dot_c/A_c) * d_h / mu_c
        if Re_c < 4000: return 1000.0
        Nu_c = 0.023 * (Re_c**0.8) * (Pr_c**0.4)
        h_c  = Nu_c * k_c / d_h
        return h_c
    except ValueError:
        return 30000.0

def q_conv_h(T_aw, T_wg, h_g):
    return h_g * (T_aw - T_wg)

def calculate_q_rad(T_gas, epsilon_eff=0.3):
    sigma_sb = 5.67e-8
    return sigma_sb * epsilon_eff * (T_gas**4)

# ==============================================================================
# (NEW) 1.5. Rib(리브) 관련 함수
# ==============================================================================
def eta_cf(h_c, w_b, delta_c, w_c, k_w):
    """리브 효율 η_c (평판핀 유사 해석식). w_b: 리브 두께, delta_c: 리브 높이"""
    mL = ((h_c * w_b / k_w)**0.5) * (delta_c / w_b)
    # tanh(mL)/(mL), mL→0 안정화
    if mL <= 1e-12:
        return 1.0
    return np.tanh(mL) / mL

def h_c_rf(h_c, eta_c, delta_c, w_c, w_b):
    """리브 반영 냉각측 등가 대류계수 h_c_r (면적 증가 효과)"""
    return h_c * (w_c + 2*eta_c*delta_c) / (w_c + w_b)

def q_cf(T_aw, T_c, h_g, t_w, k_w, h_c_r):
    """가스점착온도~냉각제 사이 종합 열유속 q_c (W/m^2)"""
    R_g = 1.0 / max(h_g, 1e-12)
    R_w = t_w / max(k_w, 1e-12)
    R_c = 1.0 / max(h_c_r, 1e-12)
    return (T_aw - T_c) / (R_g + R_w + R_c)

# ==============================================================================
# 2. 입력 변수 및 계산 준비
# ==============================================================================
nozzle_contour_data = np.array([
    [-34.8, 10.72], [-33.6, 10.76], [-31.8, 10.65], [-30.2, 10.65], [-28.3, 10.65],
    [-26.5, 10.65], [-24.5, 10.64], [-21.6, 10.64], [-20.0, 10.53], [-17.8, 10.32],
    [-15.3, 9.81], [-13.4, 9.40], [-11.3, 8.78], [-9.0, 7.96], [-7.4, 7.45],
    [-4.7, 6.53], [-2.6, 5.91], [-1.1, 5.71], [0.05, 5.81], [1.0, 6.42], [2.0, 7.33],
    [2.9, 8.05], [4.1, 8.96], [5.5, 9.88], [6.9, 11.0], [8.5, 12.12], [10.2, 13.24],
    [11.8, 14.15], [13.1, 14.96], [14.5, 15.88], [16.1, 16.80], [18.1, 17.91],
    [20.1, 19.03], [21.5, 19.74], [22.9, 20.56], [23.8, 20.96], [24.8, 21.57]
])

# --- 연소 가스 및 엔진 조건 (논문 Table 1) ---
T_0 = 3603.2
P_0 = 58.6e5
Pr_gas = 0.65
C_star = 1810

# --- 냉각 채널 제원 및 조건 (논문 Table 2) ---
wall_thickness = 0.7e-3
channel_height = 8.63e-3
channel_width  = 1.08e-3
num_channels   = 150
k_wall = 300.0
COOLANT_NAME = 'Methane'
m_dot_coolant = 10.0
T_c_inlet = 120.0
P_c_inlet = 127e5
cooling_jacket_end_ar = 15

# --- (NEW) 리브 형상 파라미터 ---
rib_height = 0.3e-3      # delta_c [m]  ← 필요에 맞게 수정
rib_width  = 0.2e-3      # w_b    [m]  ← 필요에 맞게 수정
include_radiation = True # 복사열 포함 여부 토글

# --- 파생 변수 ---
nozzle = NozzleContour(nozzle_contour_data)
D_t = nozzle.D_t
A_c_total = channel_width * channel_height * num_channels
d_h = 2 * (channel_width * channel_height) / (channel_width + channel_height)

# ==============================================================================
# 3. 계산 설정 및 프로파일 생성
# ==============================================================================
n_segments = 200
tol = 1e-3
max_iter = 100
alpha_relax = 0.2

# --- 해석 구간 설정 (수축부 끝 ~ 팽창부 AR 15) ---
x_start = nozzle.x_data_shifted[0]
x_end_search = np.linspace(0, 0.5, 500)
x_end = 0.25
for x_val in x_end_search:
    _, ar = nozzle.get_profile(x_val)
    if ar >= cooling_jacket_end_ar:
        x_end = x_val
        break

x_pos = np.linspace(x_start, x_end, n_segments)
dx = x_pos[1] - x_pos[0]

# --- 프로파일 배열 초기화 ---
D_profile  = np.zeros(n_segments)
AR_profile = np.zeros(n_segments)
T_c_profile  = np.zeros(n_segments)
P_c_profile  = np.zeros(n_segments)
T_wg_profile = np.zeros(n_segments)
T_wc_profile = np.zeros(n_segments)
q_profile    = np.zeros(n_segments)
h_g_profile  = np.zeros(n_segments)

# 냉각수 입구 조건 (해석 시작점: 노즐 출구)
T_c_profile[-1] = T_c_inlet
P_c_profile[-1] = P_c_inlet
T_wg_guess_for_next_step = 600.0

# ==============================================================================
# 4. 메인 계산 루프 (노즐 출구 -> 연소실)
# ==============================================================================
print("Starting Improved 1D thermal analysis with RIB...")

for i in range(n_segments - 1, -1, -1):
    x_local = x_pos[i]
    D_local, AR_local = nozzle.get_profile(x_local)
    D_profile[i], AR_profile[i] = D_local, AR_local

    T_c_local, P_c_local = T_c_profile[i], P_c_profile[i]

    # 1) 가스 물성/마하수
    flow_type = 'subsonic' if x_local < 0 else 'supersonic'
    gamma_guess, _, _ = get_gas_properties(2800)
    Mach_local_guess = mach_from_area_ratio(AR_local, gamma_guess, flow_type)
    T_static_local = T_0 / (1 + (gamma_guess - 1)/2 * Mach_local_guess**2)
    gamma_local, mu_gas_local, Cp_gas_local = get_gas_properties(T_static_local)
    Mach_local = mach_from_area_ratio(AR_local, gamma_local, flow_type)

    # 2) 가스측 대류계수/점착온도
    #    (초기 T_wg는 이전 스텝 예측값으로 시작하지만, q_c로 최종 업데이트)
    h_g, T_aw_local = bartz_h_g(Mach_local, T_wg_guess_for_next_step, D_t, AR_local, P_0, T_0,
                                gamma_local, mu_gas_local, Cp_gas_local, Pr_gas, C_star)

    # 3) 냉각측: 먼저 일반 h_c → 리브 효율 η_c → 등가 h_c_r
    #    (T_wc는 아직 모르므로 일단 T_wc≈T_c 가정으로 h_c 계산 시작 → q로 업데이트)
    h_c_base = calculate_h_c(m_dot_coolant, A_c_total, d_h, T_c_local, T_c_local+50.0, P_c_local, COOLANT_NAME)
    eta_c = eta_cf(h_c_base, w_b=rib_width, delta_c=rib_height, w_c=channel_width, k_w=k_wall)
    h_c_r = h_c_rf(h_c_base, eta_c, delta_c=rib_height, w_c=channel_width, w_b=rib_width)

    # 4) 리브 반영 종합 열유속 q_c (가스점착온도~냉각제 사이)
    q_c = q_cf(T_aw_local, T_c_local, h_g, wall_thickness, k_wall, h_c_r)

    # (옵션) 복사열 추가
    q_total = q_c + (calculate_q_rad(T_0) if include_radiation else 0.0)
    if q_total < 0: q_total = 0.0

    # 5) 벽면 온도 재구성 (연속 조건)
    #    q_c = h_g (T_aw - T_wg) = k/t (T_wg - T_wc) = h_c_r (T_wc - T_c)
    T_wg_new = T_aw_local - q_c / max(h_g, 1e-12)
    T_wc_new = T_c_local + q_c / max(h_c_r, 1e-12)

    # 약간의 이완 적용(수렴 안정화)
    T_wg_iter = T_wg_guess_for_next_step * (1 - alpha_relax) + T_wg_new * alpha_relax
    T_wc_iter = T_c_local + (T_wc_new - T_c_local) * alpha_relax

    T_wg_profile[i] = T_wg_iter
    T_wc_profile[i] = T_wc_iter
    q_profile[i]    = q_total
    h_g_profile[i]  = h_g
    T_wg_guess_for_next_step = T_wg_iter

    # 6) 다음 스텝(i-1) 냉각수 상태 업데이트(에너지/압력)
    if i > 0:
        A_heat_transfer = np.pi * D_local * dx   # 외주면적(원통 근사)
        Q_segment = q_total * A_heat_transfer
        try:
            Cp_c = CP.PropsSI('C', 'T', T_c_local, 'P', P_c_local, COOLANT_NAME)
            delta_T_c = Q_segment / (m_dot_coolant * Cp_c)
            T_c_profile[i-1] = T_c_local + delta_T_c
            dP = calculate_pressure_drop(m_dot_coolant, T_c_local, P_c_local, A_c_total, d_h, dx, COOLANT_NAME)
            P_c_profile[i-1] = P_c_local - dP
        except ValueError:
            T_c_profile[i-1] = T_c_local
            P_c_profile[i-1] = P_c_local

# ==============================================================================
# 5. 결과 시각화
# ==============================================================================

# Savitzky-Golay 필터 (홀수/길이 체크)
window_length = 101  # 홀수 필수
if window_length >= len(q_profile):
    window_length = max(5, len(q_profile)//2*2 - 1)  # 데이터 길이에 맞게 홀수로 보정
polyorder = 3

q_profile_smooth   = savgol_filter(q_profile, window_length, polyorder)
T_wg_profile_smooth = savgol_filter(T_wg_profile, window_length, polyorder)
T_wc_profile_smooth = savgol_filter(T_wc_profile, window_length, polyorder)

fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
fig.suptitle('1D Regenerative Cooling Analysis (with RIB)', fontsize=16)

# --- 열유량  ---
ax1_twin = ax1.twinx()
ax1.plot(x_pos, q_profile_smooth / 1e6, 'g-', label='Heat Flux (Total)')
ax1_twin.plot(x_pos, D_profile * 100 / 2, 'k', alpha=0.3, label='Nozzle Radius')
ax1.set_xlabel('Axial Position from Throat (m)')
ax1.set_ylabel('Heat Flux (MW/m^2)', color='g')
ax1_twin.set_ylabel('Nozzle Radius (cm)')
ax1.set_title('Heat Flux')
ax1.grid(True)
ax1.legend()
ax1.set_ylim(0, 50)
ax1_twin.set_ylim(0, 60)

# --- 가스 쪽 벽면  ---
ax2_twin = ax2.twinx()
ax2.plot(x_pos, T_wg_profile_smooth, 'r-', label='Gas-side Wall Temp.')
ax2_twin.plot(x_pos, D_profile*100 / 2, 'k', alpha=0.3, label='Nozzle Radius')
ax2.set_xlabel('Axial Position from Throat (m)')
ax2.set_ylabel('Temperature (K)')
ax2.set_title('Gas-side wall temperature')
ax2.grid(True)
ax2.legend()
ax2.set_ylim(0, 1500)
ax2_twin.set_ylim(0, 60)

# --- 냉각제 온도 ---
ax3_twin = ax3.twinx()
ax3.plot(x_pos, T_c_profile, 'b:', label='Coolant Bulk Temp.')
ax3_twin.plot(x_pos, D_profile*100 / 2, 'k', alpha=0.3, label='Nozzle Radius')
ax3.set_xlabel('Axial Position from Throat (m)')
ax3.set_ylabel('Coolant Temperature (K)', color='b')
ax3_twin.set_ylabel('Nozzle Radius (cm)')
ax3.set_title('Coolant Temperature')
ax3.grid(True)
ax3.legend()
ax3.set_ylim(0, 600)
ax3_twin.set_ylim(0, 60)

# --- 냉각제 압력강하 ---
ax4_twin = ax4.twinx()
ax4.plot(x_pos, P_c_profile / 1e5, 'c-', label='Coolant Pressure')
ax4_twin.plot(x_pos, D_profile*100 / 2, 'k', alpha=0.3, label='Nozzle Radius')
ax4.set_xlabel('Axial Position from Throat (m)')
ax4.set_ylabel('Coolant Pressure (bar)')
ax4.set_title('Coolant Pressure Drop')
ax4.grid(True)
ax4.legend()
ax4.set_ylim(118, 132)
ax4_twin.set_ylim(0, 60)

for ax in [ax1, ax2, ax3, ax4]:
    ax.axvline(x=0, color='grey', linewidth=1)
    ax.set_xlim(x_pos.min(), x_pos.max())

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()